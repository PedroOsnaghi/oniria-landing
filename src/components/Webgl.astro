---

---

<canvas
  id="webgl-canvas"
  class="fixed inset-0 w-full h-full -z-1 pointer-events-none"></canvas>

<script>
  import * as THREE from "three";
  import { gsap } from "gsap";
  import vertexShader from "../shaders/vertexShader.glsl";
  import fragmentShader from "../shaders/fragmentShader.glsl";
  import fragmentShaderMask from "../shaders/fragmentShaderMask.glsl";

  // Variables globales
  let node: THREE.Group;
  let camera: THREE.OrthographicCamera;
  let renderer: THREE.WebGLRenderer;
  let scene: THREE.Scene;
  let material: THREE.ShaderMaterial;

  // Inicializaci√≥n directa sin manager
  if (typeof window !== "undefined") {
    // Esperar a que GSAP est√© disponible
    const initWebGL = () => {
      try {
        console.log("üéØ Iniciando WebGL component...");

        //scene setup
        scene = new THREE.Scene();

        //Camera setup - ORTOGR√ÅFICA
        const frustumSize = 5;
        const aspect = window.innerWidth / window.innerHeight;
        camera = new THREE.OrthographicCamera(
          (frustumSize * aspect) / -2,
          (frustumSize * aspect) / 2,
          frustumSize / 2,
          frustumSize / -2,
          0.1,
          1000
        );
        camera.position.set(0, 0, 5);
        camera.lookAt(0, 0, 0);

        //Renderer setup
        const canvas = document.getElementById(
          "webgl-canvas"
        ) as HTMLCanvasElement;
        if (!canvas) {
          console.error("‚ùå Canvas not found");
          return;
        }

        renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          alpha: true,
          antialias: true,
        });

        const maxWidth = Math.min(
          window.innerWidth,
          document.documentElement.clientWidth
        );
        const maxHeight = Math.min(
          window.innerHeight,
          document.documentElement.clientHeight
        );

        renderer.setSize(maxWidth, maxHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        if (canvas) {
          canvas.style.maxWidth = "100vw";
          canvas.style.maxHeight = "100vh";
        }

        // Uniformes
        const uniformDefaults = {
          uTime: 0.0,
          uResolution: [maxWidth, maxHeight] as [number, number],
          uPlasmaStrength: 1.0,
          uGlassStrength: 1.0,
          uPlasmaRadius: 1.05,
          uFresnelWidth: 0.3,
          uFresnelIntensity: 1.8,
          uOnlyMask: 0.0,
          uFresnelBright: 1.9,
          uFresnelBrightWidth: 0.7,
          uPlasmaColor: [1.9, 1.1, 1.9] as [number, number, number],
          uPlasmaColorIntensity: 1.0,
          uPlasmaColorMap: [-0.5, 0.5, 0.001, 0.0] as [
            number,
            number,
            number,
            number,
          ],
          uPlasmaOffset: [0.3, 0.3, 0.3] as [number, number, number],
          uPlasmaAmplitude: [0.5, 0.5, 0.5] as [number, number, number],
          uPlasmaFrequency: [1.0, 1.0, 1.0] as [number, number, number],
          uPlasmaPhase: [0.5, 0.13, 0.37] as [number, number, number],
          uGlassColorBase: [0.3, 0.2, 0.9] as [number, number, number],
          uGlassOffset: [0.6, 0.6, 0.4] as [number, number, number],
          uGlassAmplitude: [0.1, 0.1, 0.8] as [number, number, number],
          uGlassFrequency: [1.0, 1.0, 1.0] as [number, number, number],
          uGlassPhase: [0.5, 0.0, 0.6] as [number, number, number],
          uGlassTint: [1.0, 0.4, 0.5] as [number, number, number],
          uSmokeDirectionOffset: 0.4,
          uSmokeTurbulence: 0.35,
          uGammaCorrection: 1.3,
        };

        //plane
        const geometry = new THREE.PlaneGeometry(5, 5, 1, 1);
        material = new THREE.ShaderMaterial({
          uniforms: {
            ...Object.fromEntries(
              Object.entries(uniformDefaults).map(([key, value]) => [
                key,
                { value },
              ])
            ),
          },
          vertexShader,
          fragmentShader,
          transparent: true,
          depthWrite: false,
          blending: THREE.NormalBlending,
        });
        const plane = new THREE.Mesh(geometry, material);

        const geometryMask = new THREE.PlaneGeometry(5, 5, 1, 1);
        const materialMask = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader: fragmentShaderMask,
          blending: THREE.NormalBlending,
        });
        const planeMask = new THREE.Mesh(geometryMask, materialMask);

        planeMask.position.set(0, 0, -0.2);
        plane.position.set(0, 0, 0.2);

        node = new THREE.Group();
        node.add(planeMask);
        node.add(plane);

        // Grupo padre para la flotaci√≥n
        const floatingGroup = new THREE.Group();
        floatingGroup.add(node);
        scene.add(floatingGroup);

        // === CONFIGURACI√ìN RESPONSIVA ===
        const baseHeight = 800;
        const baseScale = 2.8;
        const basePositionY = -2.9;

        function updateResponsiveLayout() {
          const heightRatio = window.innerHeight / baseHeight;
          const responsiveScale = baseScale * heightRatio * 0.7;
          node.scale.set(responsiveScale, responsiveScale, responsiveScale);
          const responsivePositionY = basePositionY / heightRatio;
          node.position.set(0, responsivePositionY, 0);
        }

        updateResponsiveLayout();

        // === ANIMACI√ìN DE FLOTACI√ìN SUAVE ===
        // Flotaci√≥n vertical suave
        gsap.to(floatingGroup.position, {
          y: 0.15,
          duration: 3.5,
          ease: "sine.inOut",
          repeat: -1,
          yoyo: true,
        });

        // Rotaci√≥n sutil en Z
        gsap.to(floatingGroup.rotation, {
          z: 0.02,
          duration: 4.5,
          ease: "sine.inOut",
          repeat: -1,
          yoyo: true,
        });

        // Escala muy sutil para efecto de "respiraci√≥n"
        gsap.to(floatingGroup.scale, {
          x: 1.03,
          y: 1.03,
          z: 1.03,
          duration: 2.8,
          ease: "sine.inOut",
          repeat: -1,
          yoyo: true,
        });

        // === LOOP DE ANIMACI√ìN (SOLO uTime) ===
        const clock = new THREE.Clock();

        function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();

          // Actualizar solo el tiempo del shader
          material.uniforms.uTime.value += delta;

          // Renderizar la escena
          renderer.render(scene, camera);
        }

        animate();

        // === RESIZE HANDLER ===
        function onWindowResize() {
          const aspect = window.innerWidth / window.innerHeight;
          camera.left = (frustumSize * aspect) / -2;
          camera.right = (frustumSize * aspect) / 2;
          camera.updateProjectionMatrix();

          renderer.setSize(window.innerWidth, window.innerHeight);
          material.uniforms.uResolution.value = [
            window.innerWidth,
            window.innerHeight,
          ];

          updateResponsiveLayout();
        }

        window.addEventListener("resize", onWindowResize);

        console.log("‚úÖ WebGL initialized successfully");
      } catch (error) {
        console.error("‚ùå Error initializing WebGL:", error);
      }
    };

    // Inicializar cuando est√© listo
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initWebGL);
    } else {
      initWebGL();
    }
  }
</script>
