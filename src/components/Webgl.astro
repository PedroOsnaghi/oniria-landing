---

---

<canvas
  id="webgl-canvas"
  class="fixed inset-0 w-full h-full -z-1 pointer-events-none"></canvas>

<script>
  import * as THREE from "three";
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  import vertexShader from "../shaders/vertexShader.glsl";
  import fragmentShader from "../shaders/fragmentShader.glsl";
  import fragmentShaderMask from "../shaders/fragmentShaderMask.glsl";

  // Registrar ScrollTrigger
  gsap.registerPlugin(ScrollTrigger);

  // Inicializaci√≥n directa sin manager
  if (typeof window !== "undefined") {
    // Esperar a que GSAP est√© disponible
    const initWebGL = () => {
      try {
        console.log("üéØ Iniciando WebGL component...");

        //scene setup
        const scene = new THREE.Scene();

        //Camera setup - ORTOGR√ÅFICA
        const frustumSize = 5;
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(
          (frustumSize * aspect) / -2,
          (frustumSize * aspect) / 2,
          frustumSize / 2,
          frustumSize / -2,
          0.1,
          1000
        );
        camera.position.set(0, 0, 5);
        camera.lookAt(0, 0, 0);

        //Renderer setup
        const canvas = document.getElementById(
          "webgl-canvas"
        ) as HTMLCanvasElement;
        if (!canvas) {
          console.error("‚ùå Canvas not found");
          return;
        }

        const renderer = new THREE.WebGLRenderer({
          canvas: canvas,
          alpha: true,
          antialias: true,
        });

        const maxWidth = Math.min(
          window.innerWidth,
          document.documentElement.clientWidth
        );
        const maxHeight = Math.min(
          window.innerHeight,
          document.documentElement.clientHeight
        );

        renderer.setSize(maxWidth, maxHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        if (canvas) {
          canvas.style.maxWidth = "100vw";
          canvas.style.maxHeight = "100vh";
        }

        // Uniformes
        const uniformDefaults = {
          uTime: 0.0,
          uResolution: [maxWidth, maxHeight] as [number, number],
          uPlasmaStrength: 1.0,
          uGlassStrength: 1.0,
          uPlasmaRadius: 1.05,
          uFresnelWidth: 0.3,
          uFresnelIntensity: 1.8,
          uOnlyMask: 0.0,
          uFresnelBright: 1.9,
          uFresnelBrightWidth: 0.7,
          uPlasmaColor: [1.9, 1.1, 1.9] as [number, number, number],
          uPlasmaColorIntensity: 1.0,
          uPlasmaColorMap: [-0.5, 0.5, 0.001, 0.0] as [
            number,
            number,
            number,
            number,
          ],
          uPlasmaOffset: [0.3, 0.3, 0.3] as [number, number, number],
          uPlasmaAmplitude: [0.5, 0.5, 0.5] as [number, number, number],
          uPlasmaFrequency: [1.0, 1.0, 1.0] as [number, number, number],
          uPlasmaPhase: [0.5, 0.13, 0.37] as [number, number, number],
          uGlassColorBase: [0.3, 0.2, 0.9] as [number, number, number],
          uGlassOffset: [0.6, 0.6, 0.4] as [number, number, number],
          uGlassAmplitude: [0.1, 0.1, 0.8] as [number, number, number],
          uGlassFrequency: [1.0, 1.0, 1.0] as [number, number, number],
          uGlassPhase: [0.5, 0.0, 0.6] as [number, number, number],
          uGlassTint: [1.0, 0.4, 0.5] as [number, number, number],
          uSmokeDirectionOffset: 0.4,
          uSmokeTurbulence: 0.35,
          uGammaCorrection: 1.3,
        };

        //plane
        const geometry = new THREE.PlaneGeometry(5, 5, 1, 1);
        const material = new THREE.ShaderMaterial({
          uniforms: {
            ...Object.fromEntries(
              Object.entries(uniformDefaults).map(([key, value]) => [
                key,
                { value },
              ])
            ),
          },
          vertexShader,
          fragmentShader,
          transparent: true,
          depthWrite: false,
          blending: THREE.NormalBlending,
        });
        const plane = new THREE.Mesh(geometry, material);

        const geometryMask = new THREE.PlaneGeometry(5, 5, 1, 1);
        const materialMask = new THREE.ShaderMaterial({
          vertexShader,
          fragmentShader: fragmentShaderMask,
          blending: THREE.NormalBlending,
        });
        const planeMask = new THREE.Mesh(geometryMask, materialMask);

        planeMask.position.set(0, 0, -0.2);
        plane.position.set(0, 0, 0.2);

        const node = new THREE.Group();
        node.add(planeMask);
        node.add(plane);

        // Grupo padre para la flotaci√≥n
        const floatingGroup = new THREE.Group();
        floatingGroup.add(node);
        scene.add(floatingGroup);

        // === ANIMACI√ìN DE FLOTACI√ìN CONSTANTE ===
        gsap.to(floatingGroup.position, {
          y: 0.1,
          duration: 2.5,
          ease: "sine.inOut",
          repeat: -1,
          yoyo: true,
        });

        gsap.to(floatingGroup.rotation, {
          z: 0.015,
          duration: 4,
          ease: "sine.inOut",
          repeat: -1,
          yoyo: true,
        });

        // === CONFIGURACI√ìN RESPONSIVA ===
        const baseHeight = 800;
        const baseScale = 2;
        const basePositionY = -2.9;

        function updateResponsiveLayout() {
          const heightRatio = window.innerHeight / baseHeight;
          const responsiveScale = baseScale * heightRatio * 0.7;
          node.scale.set(responsiveScale, responsiveScale, responsiveScale);
          const responsivePositionY = basePositionY / heightRatio;
          node.position.set(0, responsivePositionY, 0);
        }

        updateResponsiveLayout();

        // === ANIMACIONES DE SCROLL ===
        // Variables para scroll
        let initialScale: number;
        let initialPositionY: number;

        function updateScrollValues() {
          const heightRatio = window.innerHeight / baseHeight;
          initialScale = baseScale * heightRatio * 0.7;
          initialPositionY = basePositionY / heightRatio;
        }

        function setupScrollAnimations() {
          updateScrollValues();

          const scrollTimeline = gsap.timeline({
            scrollTrigger: {
              trigger: "body",
              start: "top top",
              end: "250% bottom",
              scrub: 0,
              anticipatePin: 1,
              fastScrollEnd: true,
              onUpdate: (self: any) => {
                console.log("ScrollTrigger progress:", self.progress);
                renderer.render(scene, camera);
              },
              onToggle: (self: any) => {
                console.log("ScrollTrigger toggle:", self.isActive);
              },
            },
          });

          // FASE 1: Mover hacia el centro
          scrollTimeline.fromTo(
            node.position,
            {
              x: 0,
              y: initialPositionY,
              z: 0,
            },
            {
              y: 0,
              duration: 50,
              ease: "none",
              onStart: () => console.log("FASE 1: Movimiento hacia el centro"),
              onComplete: () =>
                console.log("FASE 1: Completado - nodo en el centro"),
            },
            0
          );

          // FASE 2: Mover a la derecha
          scrollTimeline.to(
            node.position,
            {
              x: 1.8,
              duration: 30,
              ease: "power2.in",
              onStart: () => console.log("FASE 2: Movimiento a la derecha"),
              onComplete: () =>
                console.log("FASE 2: Completado movimiento final"),
            },
            70
          );

          // ESCALA
          scrollTimeline.fromTo(
            node.scale,
            {
              x: initialScale,
              y: initialScale,
              z: initialScale,
            },
            {
              x: 1.2,
              y: 1.2,
              z: 1.2,
              duration: 100,
              ease: "power2.inOut",
              onStart: () => console.log("Iniciando cambio de escala"),
              onComplete: () => console.log("Completado cambio de escala"),
            },
            0
          );
        }

        // Configurar scroll despu√©s de un delay
        setTimeout(() => {
          setupScrollAnimations();
          console.log("‚úÖ Scroll animations configured");
        }, 500);

        // Clock y animaci√≥n
        const clock = new THREE.Clock();

        function animate() {
          requestAnimationFrame(animate);
          const delta = clock.getDelta();
          material.uniforms.uTime.value += delta;
          renderer.render(scene, camera);
        }

        animate();

        // Resize handler
        function onWindowResize() {
          const newWidth = Math.min(
            window.innerWidth,
            document.documentElement.clientWidth
          );
          const newHeight = Math.min(
            window.innerHeight,
            document.documentElement.clientHeight
          );

          const newAspect = newWidth / newHeight;
          camera.left = (frustumSize * newAspect) / -2;
          camera.right = (frustumSize * newAspect) / 2;
          camera.updateProjectionMatrix();

          renderer.setSize(newWidth, newHeight);
          material.uniforms.uResolution.value = [newWidth, newHeight];

          updateResponsiveLayout();
          updateScrollValues();
        }

        window.addEventListener("resize", onWindowResize);

        console.log("‚úÖ WebGL initialized successfully");
      } catch (error) {
        console.error("‚ùå Error initializing WebGL:", error);
      }
    };

    // Inicializar cuando est√© listo
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initWebGL);
    } else {
      initWebGL();
    }
  }
</script>
